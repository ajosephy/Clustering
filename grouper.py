#!/usr/bin/env python

from RRATrap import read_sp_files
import numpy as np
from scipy.spatial import cKDTree

def load_sps(fn='sps.npy'):
    """
    Input: filename --> Looks for a .npy file of a single pulses recarray
           as generated by RRATrap's "read_sp_files".  
           If no such file exists, the aforementioned function is invoked 
           and the .singlepulse files in the current directory are used.
    Output: A recarray with fields for time, dm, sigma, and group.
    """
    try:
        sps1 = np.load(fn)[['time','dm','sigma']]
    except:
        print "Using .singlepulse files..."
        sps1 = read_sp_files()[['time','dm','sigma']]
    sps1 = sps1.astype([('dm',float),('time',float),('sigma',float)])
    sps2 = np.empty(sps1.shape, sps1.dtype.descr + [('group','int16')])
    for name in sps1.dtype.names:
        sps2[name] = sps1[name]
    sps2['group'] = 0
    return sps2.view(np.recarray)

def dbscan(pts, eps, minPts, scale=[80,1,0.2]):
    """
    Input:
        -pts:    numpy array of floats, either (time,dm) or (time,dm,sigma)
        -eps:    defines neighbourhood radius
        -minPts: defines noise pt threshold
        -scale:  stretches time, dm, and sigma respectively
    Output:
        -grouping: numpy array assigning a group number to each input point
    """
    pts *= scale[:pts.shape[1]]
    kdt = cKDTree(pts)
    grpID = 0
    grouping = np.zeros(len(pts),np.int16)
    discovered = set()
    visiting = []
    expanding = False
    for i in xrange(len(pts)):
        if grouping[i]: continue
        discovered.add(i)
        visiting.append(i)
        while visiting:
            cur = visiting.pop()
            neighbors = set(kdt.query_ball_point(pts[cur],eps))
            if len(neighbors) < minPts:
               grouping[cur] = -1
            else:
                if not expanding:
                    grpID += 1
                    expanding = True
                grouping[cur] = grpID
                for n in neighbors.difference(discovered):
                    discovered.add(n)
                    visiting.append(n)
        expanding = False
    return grouping
